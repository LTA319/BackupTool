# 分块传输文件路径修复说明

## 问题描述

在服务端接收分块传输的数据时（`FileReceiver` 和 `SecureFileReceiver`），文件保存的路径应该和直接传输的目的路径一样，都使用 `StorageManager.CreateBackupPathAsync()` 创建的路径。

之前的实现中，`ChunkManager.FinalizeTransferAsync()` 使用临时目录路径创建最终文件：

```csharp
// 旧的实现 - 使用临时目录
var finalPath = Path.Combine(
    Path.GetDirectoryName(session.TempDirectory) ?? Path.GetTempPath(),
    session.Metadata.FileName);
```

这导致分块传输和直接传输的文件保存位置不一致。

## 解决方案

修改 `ChunkManager.FinalizeTransferAsync()` 方法，接受一个可选的 `targetPath` 参数，允许调用者指定最终文件的保存路径。

### 修改的文件

#### 1. `src/MySqlBackupTool.Shared/Interfaces/IChunkManager.cs`

更新接口方法签名，添加可选的 `targetPath` 参数：

```csharp
/// <summary>
/// 通过重新组装所有分块来完成文件传输
/// Finalizes a file transfer by reassembling all chunks
/// </summary>
/// <param name="transferId">传输会话ID / Transfer session ID</param>
/// <param name="targetPath">最终文件的目标路径（可选，如果未提供则使用临时目录） / Target path for the final file (optional, uses temp directory if not provided)</param>
/// <returns>最终文件的路径 / Path to the finalized file</returns>
Task<string> FinalizeTransferAsync(string transferId, string? targetPath = null);
```

#### 2. `src/MySqlBackupTool.Shared/Services/ChunkManager.cs`

更新实现，支持使用提供的目标路径：

```csharp
public async Task<string> FinalizeTransferAsync(string transferId, string? targetPath = null)
{
    // ... 省略验证代码 ...

    // 创建最终文件路径 / Create final file path
    // 如果提供了目标路径则使用它，否则使用临时目录 / Use provided target path if available, otherwise use temp directory
    var finalPath = !string.IsNullOrWhiteSpace(targetPath) 
        ? targetPath 
        : Path.Combine(
            Path.GetDirectoryName(session.TempDirectory) ?? Path.GetTempPath(),
            session.Metadata.FileName);
    
    _logger.LogInformation("Using {PathType} for final file: {FinalPath}", 
        !string.IsNullOrWhiteSpace(targetPath) ? "provided target path" : "temp directory path",
        finalPath);

    // 确保目标目录存在 / Ensure target directory exists
    var targetDir = Path.GetDirectoryName(finalPath);
    if (!string.IsNullOrEmpty(targetDir) && !Directory.Exists(targetDir))
    {
        Directory.CreateDirectory(targetDir);
        _logger.LogDebug("Created target directory: {Directory}", targetDir);
    }

    // ... 重新组装块的代码 ...
}
```

#### 3. `src/MySqlBackupTool.Shared/Services/FileReceiver.cs`

更新调用，传递 `targetPath` 参数：

```csharp
if (shouldChunk)
{
    totalBytesReceived = await ReceiveFileChunkedAsync(stream, transferId, request, cancellationToken);
    finalPath = await _chunkManager.FinalizeTransferAsync(transferId, targetPath);
}
```

#### 4. `src/MySqlBackupTool.Shared/Services/SecureFileReceiver.cs`

更新调用，传递 `targetPath` 参数：

```csharp
if (shouldChunk)
{
    totalBytesReceived = await ReceiveFileChunkedAsync(stream, transferId, request, cancellationToken);
    finalPath = await _chunkManager.FinalizeTransferAsync(transferId, targetPath);
}
```

## 实现细节

### 路径创建逻辑

在 `FileReceiver` 和 `SecureFileReceiver` 的 `ProcessFileTransferAsync` 方法中，都使用相同的逻辑创建目标路径：

```csharp
// 创建备份元数据
var backupMetadata = new BackupMetadata
{
    ServerName = request.Metadata.SourceConfig?.Name ?? "Unknown",
    DatabaseName = "MySQL",
    BackupTime = request.Metadata.CreatedAt,
    BackupType = "Full",
    EstimatedSize = request.Metadata.FileSize
};

// 提取客户端配置的目标目录
string? clientTargetDirectory = request.Metadata.SourceConfig?.TargetDirectory;

// 使用客户端的目标目录（如果提供），否则使用服务器默认目录
var targetPath = await _storageManager.CreateBackupPathAsync(backupMetadata, clientTargetDirectory);

_logger.LogInformation("Using {DirectoryType} target directory for backup storage: {Directory}", 
    !string.IsNullOrWhiteSpace(clientTargetDirectory) ? "client-specified" : "server-default",
    !string.IsNullOrWhiteSpace(clientTargetDirectory) ? clientTargetDirectory : "default server path");
```

### 向后兼容性

通过将 `targetPath` 参数设置为可选（默认值为 `null`），保持了向后兼容性。如果调用者不提供 `targetPath`，`ChunkManager` 将使用原来的逻辑（临时目录）。

## 优势

1. **一致性**：分块传输和直接传输现在使用相同的路径逻辑
2. **灵活性**：支持客户端指定的目标目录
3. **向后兼容**：不破坏现有代码
4. **可维护性**：路径创建逻辑集中在 `StorageManager` 中

## 测试建议

1. 测试分块传输，验证文件保存到正确的目录
2. 测试直接传输，确保行为不变
3. 测试客户端指定目录的场景
4. 测试服务器默认目录的场景
5. 测试断点续传功能，确保路径一致性

## 编译结果

所有修改已成功编译，没有错误，仅有预期的警告（主要是平台特定API和可空引用类型相关）。

```
在 5.8 秒内生成 成功，出现 139 警告
```
